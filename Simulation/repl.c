/* This is a working simulation of the SQLite Database. 
    Working on the REPL now.
    Basic structure that follows 
    Tokenizer -> Parser -> Code Generator -> VM -> B-Tree -> Pager -> OS Interface 

    The front end consists of Tokenizer, parser and the code generator.
    The backend consists of the rest, VM, B-Tree, Pager and OS Interface.
    
    The VM takes the bytecode generated by the front-end as instructions, performs
    operations on one or more tables or indexes, each stored in a data structure known
    as a B-Tree. 

    The B-Tree consists of many nodes. Each node is one page in length. It retreives
    a page from the disk or save it back to disk by issuing commands to the pager.

    The Pager receives commands to read and write data into pages. 

    The OS Interface is the layer that differs depending on the OS SQLite is compiled.
    
    Task 1 -- Making a simple read execute print loop on the command line.


    As mentioned before, the front end of SQLite is a SQL Compiler that parses a string and outputs
    an internal representation called byte code.

    SQLIte Architecture looks like as follows ----

    Core                                                                Backend
    1. Interface -> SQL Command Processor -> Virtual Machine ---> B-Tree -> Pager -> OS Interface
                        /       ^    
                       /        I
                      /         I
                     /          I
    SQL Compiler                I                                       Accesories
    Tokenizer -> Parser -> Code Generator                   Utilites, Test Code
    
    */

   /*
        Part 3: Hard coding table to store users and looking like this -- 
        column                  type 
        id                      integer
        username                varchar(32)
        email                   varchar(255)

        Insert statement would be similar like this - >insert 1 adeep akkeelar@ieee.org
        Thus, we would have to upgrade the parsing arguments in the prepare_statement function.

        A 'Row' Data structure is required to store the parsed arguments. While SQLite uses a B-Tree,
        we can use an array to arrange the pages. 
            * Store the rows in blocks of memory called pages.
            * Each page stores as many rows as it can fit.
            * Rows are serailised into a compact representation with each page
            * Pages are only allocated as needed.
            * Keep a fixed-size array of pointers to pages.
            
        A Row would thus look like so --- 
            column              size(bytes)             offset
            id                  4                       0
            username            32                      4
            email               255                     36
            total               291


        A Table Structure points to pages of rows ad keeps track of how many rows there are. The page
        size is set to 4kb as it's the same as used in virtual memory systems in most architectures. 
        Rows should not cross page boundaries, making it easy to read/write rows.

   */

  /*
  */

    #include<stdio.h>
    #include<stdbool.h>
    #include<stdlib.h>
    #include<string.h>
    #include<stdint.h>

    typedef struct {
        char *buffer;
        size_t buffer_length;
        ssize_t input_length;
    } InputBuffer;

    typedef enum {
        EXECUTE_SUCCESS, 
        EXECUTE_TABLE_FULL
    } ExecuteResult;

    /* New functions return enums indicating success or failure. */
    typedef enum {
        META_COMMAND_SUCCESS,
        META_COMMAND_UNRECOGNISED_COMMAND
    } MetaCommndResult;

    typedef enum {
        PREPARE_SUCCESS,
        PREPARE_SYNTAX_ERROR,
        PREPARE_UNRECOGNISED_STATEMENT
    } PrepareResult;

    /* Only two statements at the moment */
    typedef enum {
        STATEMENT_INSERT,
        STATEMENT_SELECT
    } StatementType;

    /* To store the parsed arguments into a Row Datastructure inside the statement object */
    #define COLUMN_USERNAME_SIZE 32
    #define COLUMN_EMAIL_SIZE 255

    typedef struct {
        uint32_t id;
        char username[COLUMN_USERNAME_SIZE];
        char email[COLUMN_EMAIL_SIZE];
    }Row;

    typedef struct {
        StatementType type;
        Row row_to_insert; //only used by the insert statement
    } Statement;

    #define size_of_attribute(Struct,Attribute) sizeof(((Struct *)0)->Attribute)

    const uint32_t ID_SIZE = size_of_attribute(Row,id);
    const uint32_t USERNAME_SIZE = size_of_attribute(Row,username);
    const uint32_t EMAIL_SIZE = size_of_attribute(Row,email);
    const uint32_t ID_OFFSET = 0;
    const uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;
    const uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;
    const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;
    const uint32_t PAGE_SIZE = 4096;
    #define TABLE_MAX_PAGES 100
    const uint32_t ROWS_PER_PAGE = PAGE_SIZE/ROW_SIZE;
    const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

    typedef struct {
        uint32_t num_rows;
        void *pages[TABLE_MAX_PAGES];
    }Table;

    void print_row(Row* row) {
        printf("(%d, %s, %s)\n",row->id,row->username,row->email);
    }

    void serialize_row(Row* source, void* destination) {
        memcpy(destination+ID_OFFSET,&(source->id),ID_SIZE);
        memcpy(destination+USERNAME_OFFSET,&(source->username),USERNAME_SIZE);
        memcpy(destination+EMAIL_OFFSET,&(source->email),EMAIL_SIZE);
    }

    void deserialize_row(void* source, Row* destination) {
        memcpy(&(destination->id),source+ID_OFFSET,ID_SIZE);
        memcpy(&(destination->username),source+USERNAME_OFFSET,USERNAME_SIZE);
        memcpy(&(destination->email),source+EMAIL_OFFSET,EMAIL_SIZE);
    }

    void* row_slot(Table* table, u_int32_t row_num) {
        uint32_t page_num = row_num/ROWS_PER_PAGE;
        void *page = table->pages[page_num];
        if(page==NULL) {
            //Allocate memory only when we try to access page.
            page = table->pages[page_num] = malloc(PAGE_SIZE);
        }
        uint32_t row_offset = row_num%ROWS_PER_PAGE;
        uint32_t byte_offset = row_offset*ROW_SIZE;
        return page+byte_offset;
    }

    Table* new_table() {
        Table* table = (Table*)malloc(sizeof(Table));
        table->num_rows=0;
        for(uint32_t i = 0; i<TABLE_MAX_PAGES;i++) {
            table->pages[i]=NULL;
        }
        return table;
    }

    void free_table(Table* table) {
        for(int i=0;table->pages[i];i++) {
            free(table->pages[i]);
        }
        free(table);
    }


    /* InputBuffer is a small wrapper around the state we need to store to interact
    with getline() */
    InputBuffer* new_input_buffer() {
        InputBuffer* input_buffer = malloc(sizeof(InputBuffer));
        input_buffer->buffer=NULL;
        input_buffer->buffer_length=0;
        input_buffer->input_length=0;

        return input_buffer;
    }

    void close_input_buffer(InputBuffer* input_buffer) {
        free(input_buffer->buffer);
        free(input_buffer);
    }

    /* The do_meta_command is a wrapper for exisiting functionality that leaves room for more commands.*/
    MetaCommndResult do_meta_command(InputBuffer* input_buffer, Table* table) {
        if(strcmp(input_buffer->buffer,".exit")==0) {
            close_input_buffer(input_buffer);
            free_table(table);
            exit(EXIT_SUCCESS);
        } else {
            return META_COMMAND_UNRECOGNISED_COMMAND;
        }
    }

    /* IMPORTANT - SQLCompiler uderstanding only two words at the moment. */
    PrepareResult prepare_statement(InputBuffer* input_buffer, Statement* statement) {
        if(strncmp(input_buffer->buffer,"insert",6)==0) {
            statement->type = STATEMENT_INSERT;
            int args_assigned = sscanf(
                input_buffer->buffer, "insert %d %s %s", &(statement->row_to_insert.id),
                statement->row_to_insert.username, statement->row_to_insert.email
            );
            if(args_assigned<3) {
                return PREPARE_SYNTAX_ERROR;
            }
            return PREPARE_SUCCESS;
        }

        if(strcmp(input_buffer->buffer,"select")==0) {
            statement->type=STATEMENT_SELECT;
            return PREPARE_SUCCESS;
        }
        return PREPARE_UNRECOGNISED_STATEMENT;
    }

    ExecuteResult execute_insert(Statement* statement, Table* table) {
        if(table->num_rows>=TABLE_MAX_PAGES) {
            return EXECUTE_TABLE_FULL;
        }

        Row* row_to_insert = &(statement->row_to_insert);
        serialize_row(row_to_insert,row_slot(table,table->num_rows));
        table->num_rows+=1;

        return EXECUTE_SUCCESS;
    }

    ExecuteResult execute_select(Statement* statement, Table* table) {
        Row row;
        for(uint32_t i=0; i<table->num_rows; i++) {
            deserialize_row(row_slot(table,i),&row);
            print_row(&row);
        }
        return EXECUTE_SUCCESS;
    }

    ExecuteResult execute_statement(Statement* statement, Table* table) {
        switch(statement->type) {
            case (STATEMENT_INSERT):    
                return execute_insert(statement,table);
            case (STATEMENT_SELECT):    
                return execute_select(statement,table); 
        }
    }

    void print_prompt() {
        printf("db > ");
    }

    /* 
        getline takes in syntax getline(char **lineptr, size_t *n, FILE *stream)
        lineptr - a pointer to the variable to point to the buffer containing the read line.
        n - pointer to the siz of the buffer of the user.
        stream - input stream read from.
    */
    void read_input(InputBuffer* input_buffer) {
        ssize_t bytes_read = getline(&(input_buffer->buffer),&(input_buffer->buffer_length),stdin);
        if(bytes_read<=0) {
            printf("Error reading input\n");
            exit(EXIT_FAILURE);
        }

        //Ignore the trailing newline
        input_buffer->input_length=bytes_read-1;
        input_buffer->buffer[bytes_read-1]=0;
    }


    int main(int argc, char *argv[]) {
        InputBuffer* input_buffer = new_input_buffer();
        Table* table = new_table();
        while(true) {
            print_prompt();
            read_input(input_buffer);

          if(strcmp(input_buffer->buffer,".exit")==0) {
            if(input_buffer->buffer[0]=='.') {
                switch(do_meta_command(input_buffer,table)) {
                    case (META_COMMAND_SUCCESS):
                        continue;
                    case (META_COMMAND_UNRECOGNISED_COMMAND):
                        printf("Unrecognised command '%s'\n.",input_buffer->buffer);
                        continue;
                }
            }

            Statement statement;
            switch(prepare_statement(input_buffer,&statement)) {
                case (PREPARE_SUCCESS):
                    break;
                case (PREPARE_SYNTAX_ERROR):
                    printf("Syntax Error. Could not parse statement.\n");
                    continue;                    
                case (PREPARE_UNRECOGNISED_STATEMENT):
                    printf("Unrecognised keyword at start of '%s'.\n",input_buffer->buffer);
                    continue;
            }

            switch (execute_statement(&statement,table)) {
                case (EXECUTE_SUCCESS): printf("Executed.\n"); break;

                case (EXECUTE_TABLE_FULL): printf("Error: Table Full!\n"); break;        
            }
          }
        }
        return EXIT_SUCCESS;
    }