/* This is a working simulation of the SQLite Database. 
    Working on the REPL now.
    Basic structure that follows 
    Tokenizer -> Parser -> Code Generator -> VM -> B-Tree -> Pager -> OS Interface 

    The front end consists of Tokenizer, parser and the code generator.
    The backend consists of the rest, VM, B-Tree, Pager and OS Interface.
    
    The VM takes the bytecode generated by the front-end as instructions, performs
    operations on one or more tables or indexes, each stored in a data structure known
    as a B-Tree. 

    The B-Tree consists of many nodes. Each node is one page in length. It retreives
    a page from the disk or save it back to disk by issuing commands to the pager.

    The Pager receives commands to read and write data into pages. 

    The OS Interface is the layer that differs depending on the OS SQLite is compiled.
    
    Task 1 -- Making a simple read execute print loop on the command line.


    As mentioned before, the front end of SQLite is a SQL Compiler that parses a string and outputs
    an internal representation called byte code.

    SQLIte Architecture looks like as follows ----

    Core                                                                Backend
    1. Interface -> SQL Command Processor -> Virtual Machine ---> B-Tree -> Pager -> OS Interface
                        /       I    
                       /        I
                      /         I
                     /          I
    SQL Compiler                I                                       Accesories
    Tokenizer -> Parser -> Code Generator                   Utilites, Test Code
    
    */

    #include<stdio.h>
    #include<stdbool.h>
    #include<stdlib.h>
    #include<string.h>

    typedef struct {
        char *buffer;
        size_t buffer_length;
        ssize_t input_length;
    } InputBuffer;


    /* New functions return enums indicating success or failure. */
    typedef enum {
        META_COMMAND_SUCCESS,
        META_COMMAND_UNRECOGNISED_COMMAND
    } MetaCommndResult;

    typedef enum {
        PREPARE_SUCCESS,
        PREPARE_UNRECOGNISED_STATEMENT
    } PrepareResult;

    /* Only two statements at the moment */
    typedef enum {
        STATEMENT_INSERT,
        STATEMENT_SELECT
    } StatementType;

    typedef struct {
        StatementType type;
    } Statement;

    /* InputBuffer is a small wrapper around the state we need to store to interact
    with getline() */
    InputBuffer* new_input_buffer() {
        InputBuffer* input_buffer = malloc(sizeof(InputBuffer));
        input_buffer->buffer=NULL;
        input_buffer->buffer_length=0;
        input_buffer->input_length=0;

        return input_buffer;
    }

    /* The do_meta_command is a wrapper for exisiting functionality that leaves room for more commands.*/
    MetaCommndResult do_meta_command(InputBuffer* input_buffer) {
        if(strcmp(input_buffer->buffer,".exit")==0) {
            close_input_buffer(input_buffer);
            exit(EXIT_SUCCESS);
        } else {
            return META_COMMAND_UNRECOGNISED_COMMAND;
        }
    }

    /* IMPORTANT - SQLCompiler uderstanding only two words at the moment. */
    PrepareResult prepare_statement(InputBuffer* input_buffer, Statement* statement) {
        if(strncmp(input_buffer->buffer,"insert",6)==0) {
            statement->type = STATEMENT_INSERT;
            return PREPARE_SUCCESS;
        }
        if(strcmp(input_buffer->buffer,"select")==0) {
            statement->type=STATEMENT_SELECT;
            return PREPARE_SUCCESS;
        }
        return PREPARE_UNRECOGNISED_STATEMENT;
    }

    void execute_statement(Statement* statement) {
        switch(statement->type) {
            case (STATEMENT_INSERT):    
                printf("This is where we do an insert.\n");
                break;
            case (STATEMENT_SELECT):
                printf("This is where we do a select.\n");
                break;
        }
    }

    void print_prompt() {
        printf("db > ");
    }

    /* 
        getline takes in syntax getline(char **lineptr, size_t *n, FILE *stream)
        lineptr - a pointer to the variable to point to the buffer containing the read line.
        n - pointer to the siz of the buffer of the user.
        stream - input stream read from.
    */
    void read_input(InputBuffer* input_buffer) {
        ssize_t bytes_read = getline(&(input_buffer->buffer),&(input_buffer->buffer_length),stdin);
        if(bytes_read<=0) {
            printf("Error reading input\n");
            exit(EXIT_FAILURE);
        }

        //Ignore the trailing newline
        input_buffer->input_length=bytes_read-1;
        input_buffer->buffer[bytes_read-1]=0;
    }

    void close_input_buffer(InputBuffer* input_buffer) {
        free(input_buffer->buffer);
        free(input_buffer);
    }

    int main(int argc, char *argv[]) {
        InputBuffer* input_buffer = new_input_buffer();
        while(true) {
            print_prompt();
            read_input(input_buffer);

          /*  if(strcmp(input_buffer->buffer,".exit")==0) {
                close_input_buffer(input_buffer);
                exit(EXIT_SUCCESS);
            } else {
                printf("Unrecognised command '%s'.\n",input_buffer->buffer);
            } */
            if(input_buffer->buffer[0]=='.') {
                switch(do_meta_command(input_buffer)) {
                    case (META_COMMAND_SUCCESS):
                        continue;
                    case (META_COMMAND_UNRECOGNISED_COMMAND):
                        printf("Unrecognised command '%s'\n.",input_buffer->buffer);
                        continue;
                }
            }

            Statement statement;
            switch(prepare_statement(input_buffer,&statement)) {
                case (PREPARE_SUCCESS):
                    break;
                case (PREPARE_UNRECOGNISED_STATEMENT):
                    printf("Unrecognised keyword at start of '%s'.\n",input_buffer->buffer);
                    continue;
            }

            execute_statement(&statement);
            printf("Executed.\n");
        }
        return EXIT_SUCCESS;
    }