/* This is a working simulation of the SQLite Database. 
    Working on the REPL now.
    Basic structure that follows 
    Tokenizer -> Parser -> Code Generator -> VM -> B-Tree -> Pager -> OS Interface 

    The front end consists of Tokenizer, parser and the code generator.
    The backend consists of the rest, VM, B-Tree, Pager and OS Interface.
    
    The VM takes the bytecode generated by the front-end as instructions, performs
    operations on one or more tables or indexes, each stored in a data structure known
    as a B-Tree. 

    The B-Tree consists of many nodes. Each node is one page in length. It retreives
    a page from the disk or save it back to disk by issuing commands to the pager.

    The Pager receives commands to read and write data into pages. 

    The OS Interface is the layer that differs depending on the OS SQLite is compiled.
    
    Task 1 -- Making a simple read execute print loop on the command line.
    
    */

    #include<stdio.h>
    #include<stdbool.h>
    #include<stdlib.h>
    #include<string.h>

    typedef struct {
        char *buffer;
        size_t buffer_length;
        size_t input_length;
    } InputBuffer;

    /* InputBuffer is a small wrapper around the state we need to store to interact
    with getline() */
    InputBuffer* new_input_buffer() {
        InputBuffer* input_buffer = malloc(sizeof(InputBuffer));
        input_buffer->buffer=NULL;
        input_buffer->buffer_length=0;
        input_buffer->input_length=0;

        return input_buffer;
    }

    void print_prompt() {
        printf("db > ");
    }

    /* 
        getline takes in syntax getline(char **lineptr, size_t *n, FILE *stream)
        lineptr - a pointer to the variable to point to the buffer containing the read line.
        n - pointer to the siz of the buffer of the user.
        stream - input stream read from.
    */
    void read_input(InputBuffer* input_buffer) {
        ssize_t bytes_read = getline(&(input_buffer->buffer),&(input_buffer->buffer_length),stdin);
        if(bytes_read<=0) {
            printf("Error reading input\n");
            exit(EXIT_FAILURE);
        }

        //Ignore the trailing newline
        input_buffer->input_length=bytes_read-1;
        input_buffer->buffer[bytes_read-1]=0;
    }

    void close_input_buffer(InputBuffer* input_buffer) {
        free(input_buffer->buffer);
        free(input_buffer);
    }

    int main(int argc, char *argv[]) {
        InputBuffer* input_buffer = new_input_buffer();
        while(true) {
            print_prompt();
            read_input(input_buffer);

            if(strcmp(input_buffer->buffer,".exit")==0) {
                close_input_buffer(input_buffer);
                exit(EXIT_SUCCESS);
            } else {
                printf("Unrecognised command '%s'.\n",input_buffer->buffer);
            }
        }
        return EXIT_SUCCESS;
    }